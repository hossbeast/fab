# @std.y.ext
#  provides discovery formula for .y files
#  provides fabrication formula for .tab.c -> .tab.<ext>
#  provides dependencies for tab.<ext> -> .y

# var/closure
#  cc
#  cflags 
#  bison
#  bisonflags
#
#  dirs       - directories containing .y files
#  rdirs      - directories containing .y files, recursive search
#  paths      - paths to .y files
#
#  dscdirs    - (as above, but for discovery only)
#  dscrdirs   - 
#  dscpaths   - 
#
#  fabdirs    - (as above, but for fabrication/dependency only)
#  fabrdirs   - 
#  fabpaths   - 
#

# paths to y files for discovery
$ydscpaths = [
	$paths				# paths
	$dscpaths			# paths, discovery only

	[
		$dirs				# directories
		$dscdirs		# directories, discovery only
	~ ls ]

	[
		$rdirs			# recursive directories
		$rdscdirs		# recursive directories, discovery only
	~ lsr ]
~ xm/<y> ]

# paths to y files for fabrication
$yfabpaths = [
	$paths				# paths
	$dscpaths			# paths, discovery only

	[
		$dirs				# directories
		$dscdirs		# directories, discovery only
	~ ls ]

	[
		$rdirs			# recursive directories
		$rdscdirs		# recursive directories, discovery only
	~ lsr ]
~ xm/<y> ]

# discovery
[ $ydscpaths ] %
{
	    [ $bison ] [ $bisonflags ~ ss/u/fx ] -o /dev/stdout [ $@ ] [
	] | [ $cc ] [ $cflags ~ ss/u/fx ] -MM -MP -MG -xc - [
	] | gcc-dep [ $@ ~ [ rx/xs/<tab. $ext >/fx ~j ] ] [ $ext ]
}

# $bison : y -> { tab.c, tab.h }
[ $yfabpaths ~ xs/<y>/<tab.c>/y/v/d/cp/u/xs/<tab.c>/<tab.h>/z/v/dj/2/shift/pop ] :: [ $< ~ rx/xs/<tab.c>/<y>/xs/<tab.h>/<y>/ss/u ]
{
	[ $bison ] [ $bisonflags ~ ss/u/fx ] -o [ $@ ~ h/1/1 ] -d	[ $@ ~ rx/ineed/xm/<y>/ss/u ]
}

# $cc : tab.c -> tab.o via std.c
+[@std.c.ext]($cfabpaths = [ $yfabpaths ~ xs/<y>/<tab.c> ]; $cc $cflags; $cdscpaths)
