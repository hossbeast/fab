#!/usr/bin/env perl

# Copyright (c) 2012-2018 Todd Freed <todd.freed@gmail.com>
#
# This file is part of fab.
#
# fab is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# fab is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fab.  If not, see <http://www.gnu.org/licenses/>. */

use strict;
use warnings;
$SIG{__WARN__} = sub { die @_ };

use Digest::MD5;
use File::Basename;
use Fcntl qw|SEEK_SET|;

my $src_h  = $ENV{bm_source};
my $desc_c = $ENV{bm_target};
my ($name, $directories, undef) = fileparse($src_h, ".h");

# descriptor.h
my %field_codes = (
    'int'    => 1 # int
  , 'uint'   => 2 # uint
  , 'char*'  => 3 # string
  , 'list'   => 4 # list
);

# search for type_descriptor declarations in the header file
my $path = $src_h;
my %descriptors;
open FH, $path or die "open($path) : $!";
while(<FH>)
{
  if(/^extern descriptor_type descriptor_([a-zA-Z0-9_]+);$/)
  {
    $descriptors{$1} = [];
  }
}

# regex to find the corresponding struct definitions
my $type_pat = '(?:struct|union) (';
for my $name (keys %descriptors)
{
  $type_pat .= '|' if length($type_pat) > 18;
  $type_pat .= '(?:';
  for my $c (split(//, $name))
  {
    $type_pat .= "[$c]";
  }
  $type_pat .= '\b)';
}
$type_pat .= ')';
print("REGEX $type_pat\n");
$type_pat = qr/$type_pat/;

my $type = undef;
seek FH, 0, SEEK_SET or die $!;
$. = 0;
while(<FH>)
{
  chomp;
  if(/^\s*\/\//) { }
  elsif(!$type)
  {
    if(/$type_pat/)
    {
      $type = $1;
    }
  }

  # insignificant lines
  elsif(index($_, ";") == -1) { }
  elsif(/^\s*};/) { }

  # fields
  elsif(/^\s*([a-zA-Z0-9_ \*]+(?: |\*))([a-zA-Z0-9_]+);/)
  {
    my $info = "$1";
    my $name = "$2";
    $info =~ s/ +/ /g;
    $info =~ s/^enum [a-z0-9_]+ *$/int/g;
    $info =~ s/ //g;
    $info =~ s/const//g;
    $info =~ s/[0-9]+_t$//g;

    if($name =~ m/^(?:[a-zA-Z0-9_]+_)?list$/)
    {
      $info = "list";
    }

    my $field_code = $field_codes{$info};
    die "cannot interpret field '$info' : $_" unless $field_code;

    push @{$descriptors{$type}}, { name => $name, code => $field_code };
  }

  # end-of-definition
  elsif(/^\s*}[a-zA-Z0-9_ ]+;/)
  {
    $type = undef;
  }
}
close FH;

while(my($name, $type) = each %descriptors)
{
  die "type $name not found" unless scalar(@$type) > 0;
}

# match up scalar/aggregate types
while(my($name, $type) = each %descriptors)
{
  for my $field (@$type)
  {
    if($$field{code} == 3)  # string
    {
      my $x;
      for($x = 0; $x <= $#$type; $x++)
      {
        last if($$type[$x]{name} eq "$$field{name}_len");
      }

      die("subfield $$field{name}_len not found") if $x > $#$type;
      die("subfield $$field{name}_len has wrong type $$type[$x]{code}") if $$type[$x]{code} != 2;
      $$field{len_field} = splice(@$type, $x, 1);
    }
    elsif($$field{code} == 4)  # list
    {
      # list-size field
      my $x;
      for($x = 0; $x <= $#$type; $x++)
      {
        last if($$type[$x]{name} eq "$$field{name}_size");
      }

      die("subfield $$field{name}_size not found") if $x > $#$type;
      die("subfield $$field{name}_size has wrong type $$type[$x]{code}") if $$type[$x]{code} != 2;
      $$field{size_field} = splice(@$type, $x, 1);

      # list-length field
      for($x = 0; $x <= $#$type; $x++)
      {
        last if($$type[$x]{name} eq "$$field{name}_len");
      }

      die("subfield $$field{name}_len not found") if $x > $#$type;
      die("subfield $$field{name}_len has wrong type $$type[$x]{code}") if $$type[$x]{code} != 2;
      $$field{len_field} = splice(@$type, $x, 1);
    }
  }
}

# generated c file
$path = "$directories/$name.desc.c";
open FH, ">$path" or die "open($path) : $!";
print FH <<"END";
/* A desc definition file generated by fab. fab is free software released under the
   GNU General Public License.

   As a special exception, desc definition files generated by fab (including this
   desc definition file) are excluded from the license covering fab itself, even if
   substantial portions of the fab source code are copied verbatim into the desc
   definition file. You may create a larger work that contains part or all of the build
   script and distribute that work under terms of your choice. */

#include "descriptor.h"
#include "$src_h"
#include "$name.desc.h"
#include "macros.h"

END

while(my($name, $def) = each %descriptors)
{
  my $id = sprintf("0x%08x", unpack("N", Digest::MD5::md5($name)));

  print FH <<"END";
struct descriptor_type API descriptor_${name} = {
    id : $id
  , name : "$name"
  , name_len : @{[length($name)]}
  , members_len : @{[scalar(@$def)]}
  , members : (descriptor_field*[]) {
END

  my $comma = '  ';
  for my $field (@$def)
  {
    printf FH <<"END";
    $comma&descriptor_${name}_$$field{name}
END
    $comma = ", ";
  }

print FH <<"END";
  }
};

END
}

while(my($name, $def) = each %descriptors)
{
  for my $field (@$def)
  {
    my $id = sprintf("0x%08x", unpack("N", Digest::MD5::md5($name . $$field{name})));

    my $codestring = {
        1 => "DESCRIPTOR_INT"
      , 2 => "DESCRIPTOR_UINT"
      , 3 => "DESCRIPTOR_STRING"
      , 4 => "DESCRIPTOR_LIST"
    }->{$$field{code}};
    print FH <<"END";
struct descriptor_field API descriptor_${name}_$$field{name} = {
    name : "$$field{name}"
  , name_len : @{[length($$field{name})]}
  , code : $codestring
  , offset : offsetof($name, $$field{name})
END

    if($$field{code} == 1 || $$field{code} == 2)  # int
    {
      print FH "  , size : sizeof_member($name, $$field{name})\n";
    }
    if($$field{code} == 3)  # string
    {
      print FH "  , len_offset : offsetof($name, $$field{len_field}{name})\n";
    }
    elsif($$field{code} == 4)  # list
    {
      print FH "  , size_offset : offsetof($name, $$field{size_field}{name})\n";
      print FH "  , len_offset : offsetof($name, $$field{len_field}{name})\n";
    }

    print FH "};\n";
  }
}

close FH;

# generated header file
$path = "$directories/$name.desc.h";
open FH, ">$path" or die "open($path) : $!";
print FH <<"END";
/* A desc definition file generated by fab. fab is free software released under the
   GNU General Public License.

   As a special exception, desc definition files generated by fab (including this
   desc definition file) are excluded from the license covering fab itself, even if
   substantial portions of the fab source code are copied verbatim into the desc
   definition file. You may create a larger work that contains part or all of the build
   script and distribute that work under terms of your choice. */

#ifndef DESCRIPTOR_${name}_H
#define DESCRIPTOR_${name}_H

#include "descriptor.h"

END

while(my($name, $def) = each %descriptors)
{
  print FH <<"END";
extern struct descriptor_type descriptor_${name};
END

  for my $field (@$def)
  {
    print FH <<"END";
extern struct descriptor_field descriptor_${name}_$$field{name};
END
  }
}

print FH <<"END";

#endif
END
close FH;
