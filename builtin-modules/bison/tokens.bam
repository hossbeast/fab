#!/usr/bin/env perl
#
# Copyright (c) 2012-2020 Todd Freed <todd.freed@gmail.com>
#
# This file is part of fab.
#
# fab is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# fab is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fab.  If not, see <http://www.gnu.org/licenses/>. */
#

use strict;
use warnings;
$SIG{__WARN__} = sub { die @_ };

my $tab_c = substr($ENV{bm_source0}, -2) eq ".c" ? $ENV{bm_source0} : $ENV{bm_source1};
my $tab_h = substr($ENV{bm_source0}, -2) eq ".h" ? $ENV{bm_source0} : $ENV{bm_source1};
my $tokens_c = substr($ENV{bm_target0}, -2) eq ".c" ? $ENV{bm_target0} : $ENV{bm_target1};
my $tokens_h = substr($ENV{bm_target0}, -2) eq ".h" ? $ENV{bm_target0} : $ENV{bm_target1};

$tokens_c =~ m|/?([^./]+)[.]tokens[.]c$|;
my $pfx = "$1";

# bison around 3.8.2 stopped emitting yytoknum and started emitting yysymbolkind
# only one or the other has to be present
my %yytokentype;  # token name by token number
my %yysymbolkind; # symbol number by token name
my @yytname;      # token string by symbol number
my @yytoknum;     # token number by symbol number

# snarf bison datastructures
open my $fh, "<$tab_h" or die $!;
my $mode = '';
while(my $line = <$fh>)
{
  chomp $line;
  if($mode && $line =~ m/};$/)
  {
    $mode = '';
  }
  elsif($mode eq 'yytokentype')
  {
    if($line =~ m/^\s*{\s*$/)
    {
    }
    elsif($line =~ m/^\s*([A-Z0-9_]+) = (-?[0-9]+),?/i)
    {
      # use specific names for bison implementation tokens
      my $name = "$1";
      my $token = int($2);

      # these arent available from yytoknum so skip them for consistency
      next if $name =~ /yyeof/i;
      next if $name =~ /yyerror/i;
      next if $name =~ /yyundef/i;
      next if $name =~ /yyempty/i;

      $yytokentype{$token} = $name;
    }
    else
    {
      die "unexpected line";
    }
  }
  elsif($line =~ /^\s+enum [a-z_]+_yytokentype$/)
  {
    $mode = 'yytokentype';
  }
}

open $fh, "<$tab_c" or die $!;
$mode = '';
while(my $line = <$fh>)
{
  chomp $line;
  if($mode && $line =~ m/};$/)
  {
    $mode = '';
  }
  elsif($mode eq 'yytname')
  {
    while($line =~ m/"((?:(?:[^"\\])|(?:\\"))+)"/g)
    {
      push @yytname, $1;
    }
  }
  elsif($mode eq 'yytoknum')
  {
    while($line =~ m/[0-9]+/g)
    {
      push @yytoknum, int($&);
    }
  }
  elsif($mode eq 'yysymbolkind')
  {
    if($line =~ m/^\s*{\s*$/)
    {
    }
    elsif($line =~ m/^\s*YYSYMBOL_([A-Z0-9_]+) = (-?[0-9]+),?/i)
    {
      # use specific names for bison implementation tokens
      my $name = "$1";
      my $symbol = int($2);

      # these arent available from yytoknum so skip them for consistency
      next if $name =~ /yyeof/i;
      next if $name =~ /yyerror/i;
      next if $name =~ /yyundef/i;
      next if $name =~ /yyempty/i;

      $yysymbolkind{$name} = $symbol;
    }
    else
    {
      die "unexpected line";
    }
  }
  elsif($line =~ /static const char .const yytname/)
  {
    $mode = 'yytname';
  }
  elsif($line =~ /^enum yysymbol_kind_t$/)
  {
    $mode = 'yysymbolkind';
  }
  elsif($line =~ /static const yytype_int16 yytoknum/)
  {
    $mode = 'yytoknum';
  }
}

# build the token table - from yytoknum, if available
my %symbols;
for(my $x = 0; $x < scalar(@yytoknum); $x++)
{
  my $symbol = $x;
  my $token = $yytoknum[$x];
  my $string = $yytname[$x];
  my $name = $yytokentype{$token};

  # skip tokens with no name, such as punctuation characters
  next unless $name;

  # skip bison-implementation tokens
  # use specific names for bison implementation tokens
  $name = "YYEOF" if $name =~ /yyeof/i;
  $name = "YYERROR" if $name =~ /yyerror/i;
  $name = "YYUNDEF" if $name =~ /yyundef/i;

  $string =~ s/^\\"//;
  $string =~ s/\\"$//;

  $symbols{$symbol} = { name => $name, string => $string, string_len => length($string), token => $token, symbol => $symbol };
}

# build the token table
while(my($token, $name) = each %yytokentype)
{
  my $symbol = $yysymbolkind{$name};
  next unless $symbol;
  next if exists $symbols{$symbol};

  my $string = $yytname[$symbol];

  $string =~ s/^\\"//;
  $string =~ s/\\"$//;

  $symbols{$symbol} = { name => $name, string => $string, string_len => length($string), token => $token, symbol => $symbol };
}

my @tokens = sort { $$a{string} cmp $$b{string} } values %symbols;

#
# c file
#

close $fh;
open $fh, ">$tokens_c" or die $!;
print $fh <<END;
#include <stdint.h>
#include "yyutil/parser.h"
const struct yyu_token * ${pfx}_token_table = (struct yyu_token[]) {
END

for my $tok (@tokens) {
  print $fh <<END;
    { token : $$tok{token}, symbol : $$tok{symbol}, name : "$$tok{name}", string_len : $$tok{string_len}, string : "$$tok{string}" },
END
}

print $fh <<END;
};
END

#
# header file
#

close $fh;
open $fh, ">$tokens_h" or die $!;
print $fh <<END;
#ifndef ${pfx}_TOKENS_H
#define ${pfx}_TOKENS_H
#include <stdint.h>
#include "yyutil/parser.h"
extern struct yyu_token * ${pfx}_token_table;
#define ${pfx}_TOKEN_TABLE_SIZE @{[scalar(@tokens)]}
enum ${pfx}_tokens {
END

for my $token (@tokens)
{
  print $fh ("  ${pfx}_$$token{name} = $$token{token},\n");
}

print $fh <<END;
};
#endif
END
